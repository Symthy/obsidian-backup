
## ロードマップ

from CharGPT4

### 基礎編

1. **CSS Modulesの基本理解**
    - CSS Modulesとは何か、なぜ使用するのか。
    - 伝統的なCSSとの違い。
    - スコープとローカル名前空間。
2. **セットアップと構成**
    - CSS ModulesをサポートするためのWebpackやその他のビルドツールの設定。
    - Create React AppやNext.jsなどのフレームワークでの使用方法。
3. **基本的な使用方法**
    - CSSファイルの作成とモジュールとしてのインポート。
    - クラス名の適用と合成。

### 中級編

1. **ローカルとグローバルスタイルの組み合わせ**
    - ローカルスコープとグローバルスコープのスタイルの使い分け。
    - `:global` と `:local` の使用方法。
2. **依存関係と合成**
    - 他のCSSモジュールからのスタイルの継承と合成。
    - 複数のスタイルシートの組み合わせ。
3. **プリプロセッサとの統合**
    - Sass、LessなどのプリプロセッサとCSS Modulesの組み合わせ。
    - 変数、ミックスイン、関数の使用。

### 上級編

1. **動的なスタイリングとテーマ**
    - JavaScriptを使用した動的なスタイルの適用。
    - テーマの作成と適用。
2. **パフォーマンスと最適化**
    - CSS Modulesのビルドパフォーマンス。
    - 本番環境での最適化戦略。
3. **ベストプラクティスとパターン**
    - 再利用可能なコンポーネントの作成。
    - メンテナンスとスケーラビリティに関するベストプラクティス。

# 基本編
## CSS Modlues の基本

### CSS Modules とは

CSSのグローバルスコープ汚染問題を回避するための仕組み
CSS Modulesは、CSSクラス名とセレクタをローカルスコープに限定する方法です。これは、JavaScriptモジュールのように、CSSをモジュール化し、コンポーネント単位でスタイルをカプセル化するためのシステムです。

**使用する理由**:

1. **名前衝突の回避**: 
	- 伝統的なグローバルCSSでは、異なるコンポーネント間で同じクラス名を使用するとスタイルの衝突が起こる（CSS Modulesは、各クラス名をローカルスコープに限定することで、この問題を解決する）。
2. **メンテナンスの容易さ**: 
	- スタイルがコンポーネントに密接に結びついているため、コンポーネントのメンテナンスが容易
1. **再利用性の向上**: 
	- コンポーネントとそのスタイルが密接に結びついているため、再利用しやすい

### 伝統的なCSSとの違い

**伝統的なCSS**:
- グローバルスコープ: CSSのクラス名はグローバルに定義され、どのHTML要素からもアクセス可能
- 名前衝突リスク: 同じクラス名が異なるスタイルで複数回使用されると、意図しないスタイリングが適用される可能性がある

**CSS Modules**:
- ローカルスコープ: CSSクラス名は、特定のコンポーネントまたはモジュールに限定
- 自動的な一意のクラス名生成: ビルド時に、CSSクラス名が一意の識別子に変換され、名前衝突を防ぐ

### スコープとローカル名前空間

**スコープ**:
- CSS Modulesでは、各CSSファイルは独立したスコープを持ちます。これにより、クラス名がファイル内でのみ有効になり、他のCSSファイルのクラス名と衝突することがありません。

**ローカル名前空間**:
- CSS Modulesを使用すると、各クラス名はローカル名前空間に属する。これは、そのクラス名が定義された特定のCSSファイル（またはモジュール）内でのみ意味を持つ。
- JavaScriptからCSSクラス名をインポートする際には、通常、オブジェクトとしてインポートされ、そのプロパティとしてアクセスされる。これにより、スタイルの適用が明確かつ安全になる。

CSS Modulesは、特にReactやVue.jsなどのコンポーネントベースのフレームワークでの使用に適しており、**スタイルのカプセル化とメンテナンス性の向上に大きく貢献する。**

## 基本的な使用

### クラス名の合成

CSS Modulesにおけるクラス名の合成を行う具体的な例を以下に示します。この例では、2つの異なるスタイルを持つクラスを1つのHTML要素に適用する方法を説明します。

CSSファイルの例：
まず、2つの異なるスタイルを定義したCSSファイルを作成します。以下はその例です。

```css
/* styles.module.css */
.button {
  background-color: blue;
  color: white;
  padding: 10px 20px;
  border: none;
  border-radius: 5px;
}

.large {
  font-size: 20px;
  padding: 15px 30px;
}
```


JavaScriptファイルでの合成：
次に、Reactコンポーネント（または他のJavaScriptフレームワーク/ライブラリを使用している場合）でこれらのスタイルを合成します。

```javascript
import React from 'react';
import styles from './styles.module.css';

const MyButton = () => {
  return (
    <button className={`${styles.button} ${styles.large}`}>
      Click me
    </button>
  );
};

export default MyButton;
```

CSS Modulesを使用して複数のスタイルを柔軟に組み合わせ、再利用することができます。

# 中級編

## **ローカルとグローバルスタイルの組み合わせ

CSS Modulesでは、ローカルスコープとグローバルスコープのスタイルを組み合わせることができます。これにより、コンポーネント固有のスタイリングとアプリケーション全体に適用されるスタイリングを効果的に管理できます。

### ローカルスコープとグローバルスコープの使い分け

**ローカルスコープ**:
- デフォルトでは、CSS Modules内で定義されたクラスはローカルスコープになります。
- これらのスタイルは、そのCSSファイルをインポートする特定のJavaScriptファイル（コンポーネント）にのみ適用されます。
- コンポーネント固有のスタイリングに適しています。

**グローバルスコープ**:
- グローバルスコープのスタイルは、アプリケーション全体に適用されます。
- 一般的なHTML要素や、アプリケーション全体で共通のスタイルに使用されます。

### :global と :local の使用方法

**`:global`**:
- `:global` セレクタを使用すると、CSS Modules内で定義されたスタイルをグローバルスコープにすることができます。
- これは、アプリケーション全体に適用したいスタイルに使用されます。

**`:local`**:
- `:local` セレクタは、明示的にローカルスコープのスタイルを定義するために使用されます。
- 通常は必要ありませんが、グローバルスタイルとローカルスタイルを同じファイル内で混在させる場合に便利です。

### 具体例

**CSSファイルの例**:

```css
/* styles.module.css */
:local(.button) {
  background-color: blue;
  color: white;
}

:global(.primary-button) {
  background-color: green;
}
```

この例では、`.button` はローカルスコープで、`.primary-button` はグローバルスコープで定義されています。

**JavaScriptファイルでの使用**:

```javascript
import React from 'react';
import styles from './styles.module.css';

const MyButton = () => {
  return (
    <div>
      <button className={styles.button}>Local Scoped Button</button>
      <button className="primary-button">Global Scoped Button</button>
    </div>
  );
};

export default MyButton;
```

### global セレクタを使う必要がある場面

`global` セレクタを使う必要がある場面は、特定のケースに限られますが、以下のような状況では便利です：

#### 1. 既存のグローバルCSSとの統合

- **既存のスタイルシートの再利用**: 既に大規模なグローバルCSSファイルが存在し、それを新しいプロジェクトで再利用したい場合、`global` セレクタを使って既存のスタイルを適用することができます。
- **サードパーティライブラリのスタイルカスタマイズ**: 外部ライブラリやフレームワークのスタイルをカスタマイズする必要がある場合、`global` セレクタを使用してグローバルスタイルを上書きすることができます。

#### 2. 共通スタイルの適用

- **共通要素のスタイリング**: ヘッダー、フッター、ナビゲーションバーなど、アプリケーション全体で共通のUIコンポーネントにスタイルを適用する場合に便利です。
- **ベーススタイルの設定**: HTML要素（例えば、`body`, `h1`, `p` など）に対する基本的なスタイルを設定する際に使用します。

#### 3. CSSフレームワークとの統合

- **BootstrapやMaterial UIなどのフレームワーク**: これらのフレームワークはグローバルスタイルに依存しているため、`global` セレクタを使用してフレームワークのスタイルを適用することがあります。

#### 4. テーマやブランディング

- **テーマスタイルの適用**: アプリケーション全体にわたるテーマやブランディングのスタイルを適用する場合、`global` セレクタを使用して一貫性を保つことができます。

#### 実際の使用例

```css
/* styles.module.css */
:global {
  .primary-button {
    background-color: green;
    color: white;
  }

  body {
    font-family: Arial, sans-serif;
  }
}
```

#### 結論

`global` セレクタは、特定のケースで非常に便利ですが、乱用するとCSS Modulesの主な利点であるスコープ化とカプセル化が失われるため、慎重に使用する必要があります。基本的には、コンポーネント固有のスタイルにはローカルスコープを使用し、グローバルスタイルは必要最小限に留めるのが良いでしょう。

### （外部ライブラリやフレームワークの）global スタイルを上書き

外部ライブラリやフレームワークのスタイルを上書きするためには、以下の方法を検討できます：

#### 1. カスケーディングを利用する

外部ライブラリのスタイルはグローバルスコープにあるため、通常のCSSのカスケーディングルールを利用して上書きすることができます。これは、CSS Modulesを使用せずに、通常のCSSファイルで行います。

```css
/* override.css */
.btn-primary {
  background-color: #4CAF50; /* 緑色に変更 */
  border-color: #4CAF50;
}

.btn-primary:hover {
  background-color: #45a049; /* ホバー時の色を変更 */
}
```

このCSSファイルをプロジェクトにインポートすることで、Bootstrapの `.btn-primary` クラスを上書きできます。

#### 2. インラインスタイルを使用する

Reactなどのフレームワークでは、インラインスタイルを使用して直接要素にスタイルを適用することができます。これは、特定のコンポーネントに対してのみスタイルの変更を行いたい場合に有効です。

```javascript
const MyComponent = () => {
  return (
    <button style={{ backgroundColor: '#4CAF50', borderColor: '#4CAF50' }}>
      Custom Styled Button
    </button>
  );
};
```

#### 3. クラス名の追加

既存のクラス名に加えて、新しいクラス名を追加し、そのクラスでスタイルを上書きする方法もあります。CSS Modulesを使用して新しいクラスを定義し、それを元のクラス名と一緒に適用します。

```css
/* MyComponent.module.css */
.customButtonOverride {
  background-color: #4CAF50 !important; /* 緑色に変更 */
}
```

```javascript
import styles from './MyComponent.module.css';

const MyComponent = () => {
  return (
    <button className={`btn btn-primary ${styles.customButtonOverride}`}>
      Custom Styled Button
    </button>
  );
};
```

#### ★ 4. Sass の composes を使用

- `:global` セレクタを使用してグローバルスタイル（例えば、Bootstrapの `.btn-primary`）を上書きすると、その変更はアプリケーション全体に影響します。
- コンポーネント固有のスタイルを適用するには、新しいローカルクラスを作成し、必要に応じてグローバルクラスと組み合わせる方法が推奨されます。

##### 具体例

```scss
/* MyComponent.module.scss */
.customButton {
  composes: btn-primary from global;
  // 追加のカスタムスタイル
}
```

```javascript
// MyComponent.js
import React from 'react';
import styles from './MyComponent.module.scss';

const MyComponent = () => {
  return (
    <button className={styles.customButton}>Custom Styled Button</button>
  );
};
```

この例では、`composes` を使用してグローバルの `.btn-primary` スタイルをローカルの `customButton` クラスに組み込み、追加のカスタムスタイルを適用しています。

##### 参考情報

CSS Modules と Sass の組み合わせに関する公式なドキュメントは、CSS Modules の GitHub リポジトリや Sass の公式ウェブサイトには直接的な記述はありませんが、多くの開発者が実践している方法です。CSS Modules の基本的な使用方法に関しては、[CSS Modules GitHub リポジトリ](https://github.com/css-modules/css-modules)を参照してください。また、Sass の詳細については、[Sass 公式ウェブサイト](https://sass-lang.com/)が参考になります。

重要なのは、`:global` セレクタを使用する際の影響範囲を理解し、アプリケーション全体にわたるスタイルの変更に注意することです。


# 上級編

## パフォーマンスと最適化

### CSS Modulesのパフォーマンスへの影響

CSS Modulesのファイルを複数のJavaScriptファイルでimportしても、パフォーマンスへの影響は通常非常に小さいです。主な理由は以下の通りです：

1. **CSSのサイズ**: CSSファイルは通常、JavaScriptファイルに比べてサイズが小さいため、追加のCSSがアプリケーションのパフォーマンスに大きな影響を与えることは少ないです。

2. **ブラウザのキャッシュ**: ブラウザはCSSファイルをキャッシュするため、ページを再訪問する際にはキャッシュから読み込まれ、追加のダウンロード時間は発生しません。

3. **並列ダウンロード**: ブラウザは複数のファイルを並列にダウンロードできるため、複数のCSSファイルがあってもダウンロード時間に大きな影響はありません。

#### 考慮すべき点

- **重複の避け方**: 同じスタイルが複数のコンポーネントで使用される場合、共通のスタイルを別のファイルに分離し、それを必要なコンポーネントでimportすることで、重複を避けることができます。

- **クリティカルパスの最適化**: ページの読み込み速度に影響を与える「クリティカルパス」にあるCSSは、ページの初期表示に必要な最小限のスタイルに限定することが望ましいです。

#### 結論

CSS Modulesのファイルを複数のJavaScriptファイルでimportすること自体は、パフォーマンスに大きな影響を与えることは一般的にはありません。ただし、アプリケーション全体のパフォーマンスを考慮する際には、スタイルの重複やクリティカルパスの最適化などの点に注意することが重要です。

### ビルドパフォーマンスと最適化

CSS Modulesを使用する際のパフォーマンスと最適化に関して、以下の2つの主要な側面を考慮することが重要です：ビルドパフォーマンスと本番環境での最適化戦略。

#### 1. CSS Modulesのビルドパフォーマンス

CSS Modulesを使用すると、ビルド時に追加の処理が必要になります。これは、CSSクラス名を一意の識別子に変換するためです。

- **ビルド時間の増加**: CSS Modulesを処理するためには、CSSファイルを解析し、クラス名を変換する必要があります。これにより、ビルドプロセスにわずかな時間が追加される可能性があります。
- **ビルドツールの最適化**: Webpackなどのビルドツールを使用する場合、`css-loader` や `style-loader` などのローダーの設定を最適化することで、ビルドパフォーマンスを向上させることができます。例えば、キャッシュの有効化や、不要なソースマップの生成を避けることが挙げられます。

#### 2. 本番環境での最適化戦略

本番環境では、CSSのロード時間とパフォーマンスが重要になります。

- **クリティカルパスの最適化**: 初期ページロードに必要なスタイルのみを含む「クリティカルCSS」を抽出し、インラインでページに含めることで、ページの表示速度を向上させることができます。
- **不要なCSSの削除**: 使用されていないスタイルを削除することで、CSSファイルのサイズを減らし、ロード時間を短縮します。ツールを使用して未使用のCSSを特定し、削除することができます。
- **圧縮とミニファイ**: 本番環境用のCSSファイルは、圧縮（gzipなど）とミニファイ（不要な空白やコメントの削除）を行うことで、ファイルサイズを減らし、ロード時間を短縮します。
- **非同期ロード**: ページの初期ロードに不要なスタイルシートは、非同期にロードすることで、初期表示のパフォーマンスを向上させることができます。

#### 結論

CSS Modulesを使用する際は、ビルドプロセスの最適化と本番環境でのパフォーマンス向上のための戦略を考慮することが重要です。これには、ビルドツールの設定の最適化、クリティカルパスの管理、不要なスタイルの削除、ファイルの圧縮とミニファイ、そして非同期ロードの実装が含まれます。これらの戦略を適切に実施することで、パフォーマンスを最大化し、ユーザー体験を向上させることができます。

## 動的スタイリングとテーマ

